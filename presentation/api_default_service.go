/*
 * Face Detection And Recognition API
 *
 * Detect faces and recognize people from a specified image.
 *
 * API version: 0.1.9
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"bytes"
	"context"
	"errors"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/rekognition"
	"github.com/aws/aws-sdk-go-v2/service/rekognition/types"
	"gocv-sample/constant"
	"gocv.io/x/gocv"
	"golang.org/x/image/draw"
	"image"
	"image/png"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
)

// DefaultApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
	classifier *gocv.CascadeClassifier
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService(classifierFileName string) (DefaultApiServicer, error) {

	// load classifier file for face detection
	classifier := gocv.NewCascadeClassifier()
	if !classifier.Load(classifierFileName) {
		return &DefaultApiService{}, errors.New("cannot load classifier file")
	}

	return &DefaultApiService{
		classifier: &classifier,
	}, nil
}

// V1AuthPost - Returns whether specified user is identified.
func (s *DefaultApiService) V1AuthPost(ctx context.Context, storeIdParam string, fileHeader *multipart.FileHeader) (ImplResponse, error) {
	// open request file
	file, err := fileHeader.Open()
	if err != nil {
		log.Printf("failed to open image file. err=%v", err)

		errorCode := constant.ET5001
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}
	defer file.Close()

	imgBytes, err := ioutil.ReadAll(file)
	if err != nil {
		log.Printf("failed to read image file. err=%v", err)

		errorCode := constant.ET5002
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	// resize image
	buffer := new(bytes.Buffer)
	_, err = buffer.ReadFrom(file)
	if err != nil {
		log.Printf("cannot decode image file err=%v", err)

		errorCode := constant.ET5003
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	imgSrc, t, err := image.Decode(buffer)
	if err != nil {
		log.Printf("cannot decode image file err=%v", err)

		errorCode := constant.ET5003
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	rctSrc := imgSrc.Bounds()
	log.Printf("Type of image: %v", t)
	imgDst := image.NewRGBA(image.Rect(0, 0, rctSrc.Dx()/2, rctSrc.Dy()/2))
	draw.CatmullRom.Scale(imgDst, imgDst.Bounds(), imgSrc, rctSrc, draw.Over, nil)

	resizedBuffer := new(bytes.Buffer)
	err = png.Encode(resizedBuffer, imgDst)
	if err != nil {
		log.Printf("cannot encode image file err=%v", err)

		errorCode := constant.ET5003
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	// decode face image for face detection
	img, err := gocv.IMDecode(imgBytes, gocv.IMReadColor)
	if err != nil {
		log.Printf("cannot decode image file err=%v", err)

		errorCode := constant.ET5003
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}
	defer img.Close()

	// resize image
	//resizedImg := gocv.NewMatWithSize(640, 480, img.Type())
	resizedImg := img
	defer resizedImg.Close()
	//image, err := resizedImg.ToImage()
	//gocv.Resize(img, &resizedImg, image.Point{X: 640, Y: 480}, 0, 0, gocv.InterpolationDefault)
	log.Printf("resized width: %d", resizedImg.Cols())
	log.Printf("resized height: %d", resizedImg.Rows())

	// execute face detection
	rects := s.classifier.DetectMultiScale(resizedImg)

	if len(rects) < 1 {
		log.Printf("failed to detect face form image. err=%d", len(rects))

		errorCode := constant.EC4001
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	// output face detection result
	for i, e := range rects {
		log.Printf("rectangle(%d) axis -> %s\n", i+1, e.String())
	}

	log.Printf("storeId: %s", storeIdParam)

	// search image from Amazon Rekognition.
	log.Printf("imgBytes length: %d, buf length: %d", len(imgBytes), len(resizedBuffer.Bytes()))
	output, err := s.SearchFacesByImage(resizedBuffer.Bytes())
	if err != nil {
		log.Printf("failed to search image from aws rekognition err=%v", err)

		errorCode := constant.ET5004
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}
	log.Printf("search output: %v", output)

	numOfFacesMatch := len(output.FaceMatches)
	log.Printf("%d faces match", numOfFacesMatch)

	if numOfFacesMatch < 1 {
		errorCode := constant.EC4002
		return Response(errorCode.StatusCode, V1AuthPost500Response{
			Code:        errorCode.FullCode(),
			Message:     errorCode.Message,
			Description: errorCode.Detail,
		}), nil
	}

	for _, e := range output.FaceMatches {
		log.Printf("imageId: %v, similarity: %v", e.Face.ImageId, e.Similarity)
	}
	return Response(http.StatusOK, nil), nil
}

func (s *DefaultApiService) SearchFacesByImage(imgBytes []byte) (*rekognition.SearchFacesByImageOutput, error) {
	ctx := context.TODO()

	// https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/gov2/rekognition/DetectFaces
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return &rekognition.SearchFacesByImageOutput{}, err
	}
	cfg.Region = "ap-northeast-1"

	client := rekognition.NewFromConfig(cfg)
	collectionId := "gocv-sample-collection"
	var faceMatchThreshold float32 = 95.000000
	var maxFaces int32 = 2
	input := &rekognition.SearchFacesByImageInput{
		CollectionId:       &collectionId,
		FaceMatchThreshold: &faceMatchThreshold,
		Image: &types.Image{
			Bytes: imgBytes,
		},
		MaxFaces: &maxFaces,
	}

	return client.SearchFacesByImage(ctx, input)
}
